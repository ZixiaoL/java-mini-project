package edu.nyu.cs9053.homework2;

/**
 * User: blangel
 */
public class VehicleDataParser {

    /**
     * Given a 4 byte response, {@code mode01Pid00Response}, parse according to the {@literal SAE J1979} documentation.
     * For example, if {@code mode01Pid00Response} was {@literal 0xBE1FA813} the return value would be equal to:
     * {@literal new int[] { 0x01, 0x03, 0x04, 0x05, 0x06, 0x07, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x13, 0x15, 0x1C, 0x1F, 0x20}}
     * @param mode01Pid00Response four byte response
     * @return an array of supported PID values given the input, {@code mode01Pid00Response}
     * @see {@literal https://en.wikipedia.org/wiki/OBD-II_PIDs#Service_01_PID_00}
     */
    public static int[] supportedPids(int mode01Pid00Response) {
	//Array allPids memorize each number is supported or not
	//since we haven't learned how to append an element at the back or front of an array, I use two arrays here
	//array allPids gives us information about the output array size and which numbers should be supported
	//array supportedPids is the output which is generated by walking through allPids once
	boolean[] allPids = new boolean[32];
	int rightShiftTimes = 32;
	int supportedPidSize = 0;
	//Check the LSB(least significant bit) continuously and right shift the input for one bit each time
	//if the LSB is 1((LSB & 1) == 1), set the corresponding element in array allPids to be true
	while(rightShiftTimes-- > 0){
	    if((mode01Pid00Response & 1) == 1){
		allPids[rightShiftTimes] = true;
		supportedPidSize++;
	    }
	    mode01Pid00Response = mode01Pid00Response >> 1;
	}
	//Finally walk through the array allPids and generate the output
	int[] supportedPids = new int[supportedPidSize];
	for(int i = 31; i >= 0; i--){
	    if(allPids[i]){
		supportedPids[--supportedPidSize] = i+1;
	    }
	}
	return supportedPids;
    }

    /**
     * Given a {@code pid} between [0x1,0x20] return true iff {@code mode01Pid00Response} supports it.
     * @param pid value between [0x1,0x20] to check for support within {@code mode01Pid00Response}
     * @param mode01Pid00Response four byte response
     * @return true iff {@code mode01Pid00Response} supports {@code pid}.
     * @throws IllegalArgumentException if {@code pid} is less than 0x1 or greater than 0x20
     */
    public static boolean isSupported(int pid, int mode01Pid00Response){
	//Throws IllegalArgumentException if pid is less than 0x1 or greater than 0x20
	if(pid <= 0 || pid > 32){
	    throw new IllegalArgumentException("pid less than 0x1 or greater than 0x20");
	}
	//Generate all supported pids using function supportedPids()
	int[] supportedPids = supportedPids(mode01Pid00Response);
	//Compare each supported pid with input, if we ceind one match then this pid is supported
	for(int supportedPid : supportedPids){
	    if(supportedPid == pid){
		return true;
	    }
	}
	//Otherwise input is not supported
	return false;
    }

}
